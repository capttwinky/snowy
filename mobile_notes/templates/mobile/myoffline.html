<html>
    <head>
        <title>Slick Notes</title>
        <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
        <script type="text/javascript">

        var TomboyWeb = {
            root_uri: '{{ root_uri }}',
            notes_uri: null,

            _get_notes: function(params, callback) {
                if(this.notes_uri == null) {
                    var that = this;
                    $.getJSON(this.root_uri, null, function(root) {
                        $.getJSON(root['user-ref']['api-ref'], null, function(user) {
                            that.notes_uri = user['notes-ref']['api-ref'];
                            that._get_notes(params, callback);
                        });
                    });
                } else {
                    // TODO: On certain errors, set notes_uri to null and
                    //       start from scratch
                    $.getJSON(this.notes_uri, params, callback);
                }
            },

            get_updates_since: function(version, noteJsonCallback) {
                this._get_notes({include_notes:true, since:version},
                                noteJsonCallback);
            },

            get_note_list: function(minimalNoteJsonCallback) {
                this._get_notes(null, minimalNoteJsonCallback);
            }
        };

        var OfflineNotesDatabase = {
            db: null,

            init_db: function() {
                // NOTE: openDatabase can only be called once, so init_db should
                //       also only be called once (could protect against this?)
                this.db = openDatabase('Notes', 0.1, 'Tomboy Online Notes', 5*1024*1024);
                this.check_db();
            },

            check_db: function() {
                // TODO: Error-checking, encapuslation, etc
                this.db.transaction(function(tx) {
                    tx.executeSql('CREATE TABLE IF NOT EXISTS ' +
                                  'notes(guid TEXT PRIMARY KEY ON CONFLICT REPLACE, title TEXT, content TEXT)',
                                  []);
                });
            },

            wipe_db: function() {
                this.db.transaction(function(tx) {
                    tx.executeSql('DROP TABLE notes');
                });
            },

            insert_note: function(guid, title, content, insertedRowCallback) {
                // TODO: Should we handle case where there is no desired callback?
                this.db.transaction(function(tx) {
                    tx.executeSql('INSERT INTO notes(guid, title, content) VALUES (?,?,?)',
                                  [guid, title, content],
                                  insertedRowCallback,
                                  OfflineNotesDatabase.on_error);
                });
            },

            _select_from_notes: function(params, where, selectedRowCallback) {
                var sql = "SELECT " + params + " FROM notes";
                if(where) {
                    sql += " WHERE " + where;
                }
                var selection_processor = function(tx, rs) {
                    for(var i=0; i < rs.rows.length; i++) {
                        var note = rs.rows.item(i);
                        selectedRowCallback(note);
                    }
                };
                this.db.readTransaction(function(tx) {
                    tx.executeSql(sql,
                                  [],
                                  selection_processor,
                                  OfflineNotesDatabase.on_error);
                });
            },

            select_notes: function(selectedRowCallback) {
                this._select_from_notes("*", null, selectedRowCallback);
            },

            select_note_guids: function(selectedRowCallback) {
                this._select_from_notes("guid", null, selectedRowCallback);
            },

            deleteAtGuid: function(guid, onSuccess) {
                this.db.transaction(function(tx) {
                    tx.executeSql("DELETE FROM notes WHERE guid=?", [guid],
                                  onSuccess,
                                  OfflineNotesDatabase.on_error);
                });
            },

            on_error: function(tx, e) {
                alert("There has been a db error: " + e.message);
            },
        };

        OfflineNotesDatabase.init_db();
        var lastSyncRev = localStorage.getItem('latest-sync-revision');
        if (lastSyncRev == null)
            lastSyncRev = -1;

        TomboyWeb.get_updates_since(lastSyncRev, function(notes) {
            for(var i=0; i < notes.notes.length; i++) {
                var note = notes.notes[i];
                // NOTE: Tricky ON CONFLICT REPLACE option makes this INSERT
                //       magically turn into a DELETE+INSERT if the row already
                //       exists.
                // TODO: This is probably wasteful since we should most likely
                //       prefer optimizing the UPDATE case over the new INSERT
                //       case.
                OfflineNotesDatabase.insert_note(note.guid, note.title, note['note-content']);
            }
            // TODO: Error-handling whenever using localStorage
            localStorage.setItem('latest-sync-revision', notes['latest-sync-revision']);
        });

        // Look for note that have been deleted on the server
        TomboyWeb.get_note_list(function(noteInfo) {
            var allNoteGuids = [];
            for(var i=0; i < noteInfo.notes.length; i++) {
                allNoteGuids.push(noteInfo.notes[i].guid);
            }
            OfflineNotesDatabase.select_note_guids(function(noteInfo) {
                var guid = noteInfo.guid;
                if (allNoteGuids.indexOf(guid) == -1) {
                    OfflineNotesDatabase.deleteAtGuid(guid);
                    // TODO: Do this onSuccess?
                    $('#note-title-list > li#' + guid).remove()
                }
            });
        });

        // TODO: Above method calls are async, so this may not return the
        //       desired data when called sequentially like this. Dumping into
        //       above call at end of loop doesn't necessarily fix because DB
        //       calls are also async (right?).  Need to figure out cleanest
        //       solution.  Setting a timer at end of above call might be
        //       easiest?
        OfflineNotesDatabase.select_notes(function(note) {
            $('<li id="' + note.guid + '">' + note.title + '</li>').appendTo('#note-title-list');
        });

        $(function() {
            $('#wipe')[0].addEventListener('click', function(event) {
                OfflineNotesDatabase.wipe_db();
                localStorage.setItem('latest-sync-revision', -1);
                $('#note-title-list > li').remove();
            });
        });
        </script>
    </head>

    <body>

        <p id="status">Nothing yet</p>

        <p>Feeling uncomfortable? Why don't you go ahead and
        <a href="#" id="wipe">clear all offline storage</a>?</p>

        <ul id="note-title-list" />

    </body>
</html>
